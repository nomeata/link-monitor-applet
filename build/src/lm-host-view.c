/* Generated by GOB (v2.0.15)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 15

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "lm-host-view.h"

#include "lm-host-view-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 25 "src/lm-host-view.gob"

#include <glib/gi18n.h>
#include "lm-cell-renderer-color.h"
#include "lm-host-frontend.h"
#include "lm-util.h"

enum {
  COLUMN_HOST,
  COLUMN_COLOR,
  COLUMN_NAME,
  N_COLUMNS
};

typedef enum {
  CLIPBOARD_TARGET_NATIVE,
  CLIPBOARD_TARGET_TEXT
} ClipboardTarget;

#define CLIPBOARD_TARGET_NATIVE_NAME	"x-special/link-monitor-applet-hosts"

static GdkAtom clipboard_target_native_atom;

static GtkClipboard *global_clipboard;

#line 51 "lm-host-view.c"
/* self casting macros */
#define SELF(x) LM_HOST_VIEW(x)
#define SELF_CONST(x) LM_HOST_VIEW_CONST(x)
#define IS_SELF(x) LM_IS_HOST_VIEW(x)
#define TYPE_SELF LM_TYPE_HOST_VIEW
#define SELF_CLASS(x) LM_HOST_VIEW_CLASS(x)

#define SELF_GET_CLASS(x) LM_HOST_VIEW_GET_CLASS(x)

/* self typedefs */
typedef LMHostView Self;
typedef LMHostViewClass SelfClass;

/* here are local prototypes */
static void ___object_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
static void ___object_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);
#line 0 "src/lm-host-view.gob"
static void lm_host_view_init (LMHostView * o);
#line 70 "lm-host-view.c"
#line 79 "src/lm-host-view.gob"
static void lm_host_view_class_init (LMHostViewClass * class);
#line 73 "lm-host-view.c"
#line 104 "src/lm-host-view.gob"
static void lm_host_view_constructor (LMHostView * self);
#line 76 "lm-host-view.c"
#line 207 "src/lm-host-view.gob"
static GSList * lm_host_view_get_selected_rows (LMHostView * self);
#line 79 "lm-host-view.c"
#line 232 "src/lm-host-view.gob"
static void lm_host_view_store_remove (LMHostView * self, GtkListStore * store, GtkTreeIter * iter);
#line 82 "lm-host-view.c"
#line 243 "src/lm-host-view.gob"
static void lm_host_view_reorder (LMHostView * self);
#line 85 "lm-host-view.c"
static void ___real_lm_host_view_activate_add (LMHostView * self);
static void ___real_lm_host_view_activate_move (LMHostView * self, int direction);
static void ___real_lm_host_view_activate_remove (LMHostView * self);
#line 349 "src/lm-host-view.gob"
static void lm_host_view_remove_selected_hosts (LMHostView * self);
#line 91 "lm-host-view.c"
#line 385 "src/lm-host-view.gob"
static void lm_host_view_copy_selected_hosts (LMHostView * self);
#line 94 "lm-host-view.c"
#line 440 "src/lm-host-view.gob"
static void lm_host_view_get_clipboard_cb (GtkClipboard * clipboard, GtkSelectionData * selection_data, unsigned int info, gpointer user_data_or_owner);
#line 97 "lm-host-view.c"
#line 486 "src/lm-host-view.gob"
static void lm_host_view_clear_clipboard_cb (GtkClipboard * clipboard, gpointer user_data_or_owner);
#line 100 "lm-host-view.c"
static void ___real_lm_host_view_activate_cut (LMHostView * self);
#line 494 "src/lm-host-view.gob"
static void lm_host_view_activate_cut (LMHostView * self);
#line 104 "lm-host-view.c"
static void ___real_lm_host_view_activate_copy (LMHostView * self);
#line 501 "src/lm-host-view.gob"
static void lm_host_view_activate_copy (LMHostView * self);
#line 108 "lm-host-view.c"
static void ___real_lm_host_view_activate_paste (LMHostView * self);
#line 507 "src/lm-host-view.gob"
static void lm_host_view_activate_paste (LMHostView * self);
#line 112 "lm-host-view.c"
#line 557 "src/lm-host-view.gob"
static void lm_host_view_add_host (LMHostView * self, LMHostFrontend * host);
#line 115 "lm-host-view.c"
#line 575 "src/lm-host-view.gob"
static void lm_host_view_selection_changed_h (GtkTreeSelection * selection, gpointer user_data);
#line 118 "lm-host-view.c"
#line 584 "src/lm-host-view.gob"
static void lm_host_view_color_activated_h (LMCellRendererColor * renderer, const char * path, gpointer user_data);
#line 121 "lm-host-view.c"
#line 629 "src/lm-host-view.gob"
static void lm_host_view_color_dialog_response_h (GtkDialog * dialog, int response, gpointer user_data);
#line 124 "lm-host-view.c"
#line 663 "src/lm-host-view.gob"
static void lm_host_view_color_dialog_weak_notify_cb (gpointer data, GObject * former_dialog);
#line 127 "lm-host-view.c"
#line 674 "src/lm-host-view.gob"
static void lm_host_view_editing_started_h (GtkCellRenderer * renderer, GtkCellEditable * editable, char * path, gpointer user_data);
#line 130 "lm-host-view.c"
#line 685 "src/lm-host-view.gob"
static void lm_host_view_editing_canceled_h (GtkCellRenderer * renderer, gpointer user_data);
#line 133 "lm-host-view.c"
#line 703 "src/lm-host-view.gob"
static void lm_host_view_edited_h (GtkCellRendererText * renderer, const char * path_string, const char * new_text, gpointer user_data);
#line 136 "lm-host-view.c"
#line 748 "src/lm-host-view.gob"
static void lm_host_view_update_sensitivity (LMHostView * self);
#line 139 "lm-host-view.c"
#line 808 "src/lm-host-view.gob"
static void lm_host_view_popup_menu (LMHostView * self, int button, guint32 activate_time);
#line 142 "lm-host-view.c"
#line 825 "src/lm-host-view.gob"
static void lm_host_view_popup_menu_targets_received_cb (GtkClipboard * clipboard, GdkAtom * atoms, int n_atoms, gpointer data);
#line 145 "lm-host-view.c"
#line 845 "src/lm-host-view.gob"
static gboolean lm_host_view_can_paste (GdkAtom * atoms, int n_atoms);
#line 148 "lm-host-view.c"
#line 857 "src/lm-host-view.gob"
static gboolean lm_host_view_popup_menu_h (GtkWidget * widget, gpointer user_data);
#line 151 "lm-host-view.c"
#line 868 "src/lm-host-view.gob"
static gboolean lm_host_view_button_press_event_h (GtkWidget * widget, GdkEventButton * event, gpointer user_data);
#line 154 "lm-host-view.c"
#line 879 "src/lm-host-view.gob"
static void lm_host_view_select_all_activate_h (GtkMenuItem * item, gpointer user_data);
#line 157 "lm-host-view.c"
#line 889 "src/lm-host-view.gob"
static void lm_host_view_up_activate_h (GtkMenuItem * item, gpointer user_data);
#line 160 "lm-host-view.c"
#line 896 "src/lm-host-view.gob"
static void lm_host_view_down_activate_h (GtkMenuItem * item, gpointer user_data);
#line 163 "lm-host-view.c"
#line 903 "src/lm-host-view.gob"
static gboolean lm_host_view_search_equal_cb (GtkTreeModel * model, int column, const char * key, GtkTreeIter * iter, gpointer search_data);
#line 166 "lm-host-view.c"

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__activate_add(object,func,data)	lm_host_view_connect__activate_add((object),(func),(data))
#define self_connect_after__activate_add(object,func,data)	lm_host_view_connect_after__activate_add((object),(func),(data))
#define self_connect_data__activate_add(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_add((object),(func),(data),(destroy_data),(flags))
#define self_connect__activate_move(object,func,data)	lm_host_view_connect__activate_move((object),(func),(data))
#define self_connect_after__activate_move(object,func,data)	lm_host_view_connect_after__activate_move((object),(func),(data))
#define self_connect_data__activate_move(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_move((object),(func),(data),(destroy_data),(flags))
#define self_connect__activate_remove(object,func,data)	lm_host_view_connect__activate_remove((object),(func),(data))
#define self_connect_after__activate_remove(object,func,data)	lm_host_view_connect_after__activate_remove((object),(func),(data))
#define self_connect_data__activate_remove(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_remove((object),(func),(data),(destroy_data),(flags))
#define self_connect__activate_cut(object,func,data)	lm_host_view_connect__activate_cut((object),(func),(data))
#define self_connect_after__activate_cut(object,func,data)	lm_host_view_connect_after__activate_cut((object),(func),(data))
#define self_connect_data__activate_cut(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_cut((object),(func),(data),(destroy_data),(flags))
#define self_connect__activate_copy(object,func,data)	lm_host_view_connect__activate_copy((object),(func),(data))
#define self_connect_after__activate_copy(object,func,data)	lm_host_view_connect_after__activate_copy((object),(func),(data))
#define self_connect_data__activate_copy(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_copy((object),(func),(data),(destroy_data),(flags))
#define self_connect__activate_paste(object,func,data)	lm_host_view_connect__activate_paste((object),(func),(data))
#define self_connect_after__activate_paste(object,func,data)	lm_host_view_connect_after__activate_paste((object),(func),(data))
#define self_connect_data__activate_paste(object,func,data,destroy_data,flags)	lm_host_view_connect_data__activate_paste((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (LMHostView *, gint , gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((LMHostView *)data1,
		(gint ) g_value_get_int (param_values + 1),
		data2);
}


enum {
	ACTIVATE_ADD_SIGNAL,
	ACTIVATE_MOVE_SIGNAL,
	ACTIVATE_REMOVE_SIGNAL,
	ACTIVATE_CUT_SIGNAL,
	ACTIVATE_COPY_SIGNAL,
	ACTIVATE_PASTE_SIGNAL,
	LAST_SIGNAL
};

enum {
	PROP_0,
	PROP_APPLET,
	PROP_EDITING_HOST,
	PROP_CAN_GO_UP,
	PROP_CAN_GO_DOWN
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GtkTreeViewClass *parent_class = NULL;

/* Short form macros */
#define self_get_editing_host lm_host_view_get_editing_host
#define self_set_editing_host lm_host_view_set_editing_host
#define self_get_can_go_up lm_host_view_get_can_go_up
#define self_set_can_go_up lm_host_view_set_can_go_up
#define self_get_can_go_down lm_host_view_get_can_go_down
#define self_set_can_go_down lm_host_view_set_can_go_down
#define self_get_selected_rows lm_host_view_get_selected_rows
#define self_store_remove lm_host_view_store_remove
#define self_reorder lm_host_view_reorder
#define self_activate_add lm_host_view_activate_add
#define self_activate_move lm_host_view_activate_move
#define self_activate_remove lm_host_view_activate_remove
#define self_remove_selected_hosts lm_host_view_remove_selected_hosts
#define self_copy_selected_hosts lm_host_view_copy_selected_hosts
#define self_get_clipboard_cb lm_host_view_get_clipboard_cb
#define self_clear_clipboard_cb lm_host_view_clear_clipboard_cb
#define self_activate_cut lm_host_view_activate_cut
#define self_activate_copy lm_host_view_activate_copy
#define self_activate_paste lm_host_view_activate_paste
#define self_add_host lm_host_view_add_host
#define self_selection_changed_h lm_host_view_selection_changed_h
#define self_color_activated_h lm_host_view_color_activated_h
#define self_color_dialog_response_h lm_host_view_color_dialog_response_h
#define self_color_dialog_weak_notify_cb lm_host_view_color_dialog_weak_notify_cb
#define self_editing_started_h lm_host_view_editing_started_h
#define self_editing_canceled_h lm_host_view_editing_canceled_h
#define self_edited_h lm_host_view_edited_h
#define self_update_sensitivity lm_host_view_update_sensitivity
#define self_popup_menu lm_host_view_popup_menu
#define self_popup_menu_targets_received_cb lm_host_view_popup_menu_targets_received_cb
#define self_can_paste lm_host_view_can_paste
#define self_popup_menu_h lm_host_view_popup_menu_h
#define self_button_press_event_h lm_host_view_button_press_event_h
#define self_select_all_activate_h lm_host_view_select_all_activate_h
#define self_up_activate_h lm_host_view_up_activate_h
#define self_down_activate_h lm_host_view_down_activate_h
#define self_search_equal_cb lm_host_view_search_equal_cb
#define self_new lm_host_view_new
GType
lm_host_view_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (LMHostViewClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) lm_host_view_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (LMHostView),
			0 /* n_preallocs */,
			(GInstanceInitFunc) lm_host_view_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_TREE_VIEW, "LMHostView", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((LMHostView *)g_object_new(lm_host_view_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static LMHostView * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static LMHostView *
GET_NEW_VARG (const char *first, ...)
{
	LMHostView *ret;
	va_list ap;
	va_start (ap, first);
	ret = (LMHostView *)g_object_new_valist (lm_host_view_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static GObject *
___constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_properties)
{
#define __GOB_FUNCTION__ "LM:Host:View::constructor"
	GObject *obj_self;
	LMHostView *self;
	obj_self = G_OBJECT_CLASS (parent_class)->constructor (type, n_construct_properties, construct_properties);
	self = LM_HOST_VIEW (obj_self);
#line 104 "src/lm-host-view.gob"
	lm_host_view_constructor (self);
#line 337 "lm-host-view.c"
	return obj_self;
}
#undef __GOB_FUNCTION__


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "LM:Host:View::finalize"
	LMHostView *self G_GNUC_UNUSED = LM_HOST_VIEW (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
#line 55 "src/lm-host-view.gob"
	if(self->_priv->menu) { gtk_widget_destroy ((gpointer) self->_priv->menu); self->_priv->menu = NULL; }
#line 353 "lm-host-view.c"
#line 76 "src/lm-host-view.gob"
	if(self->_priv->color_dialog) { gtk_widget_destroy ((gpointer) self->_priv->color_dialog); self->_priv->color_dialog = NULL; }
#line 356 "lm-host-view.c"
}
#undef __GOB_FUNCTION__

static void 
lm_host_view_init (LMHostView * o G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "LM:Host:View::init"
	o->_priv = G_TYPE_INSTANCE_GET_PRIVATE(o,LM_TYPE_HOST_VIEW,LMHostViewPrivate);
#line 55 "src/lm-host-view.gob"
	o->_priv->menu = gtk_menu_new();
#line 367 "lm-host-view.c"
}
#undef __GOB_FUNCTION__
#line 79 "src/lm-host-view.gob"
static void 
lm_host_view_class_init (LMHostViewClass * class G_GNUC_UNUSED)
{
#line 374 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) class;

	g_type_class_add_private(class,sizeof(LMHostViewPrivate));

	parent_class = g_type_class_ref (GTK_TYPE_TREE_VIEW);

	object_signals[ACTIVATE_ADD_SIGNAL] =
		g_signal_new ("activate_add",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_add),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);
	object_signals[ACTIVATE_MOVE_SIGNAL] =
		g_signal_new ("activate_move",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_move),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_INT);
	if ___GOB_UNLIKELY(sizeof(int ) != sizeof(gint ) || parent_class == NULL /* avoid warning */) {
		g_error("src/lm-host-view.gob line 288: Type mismatch of \"activate_move\" signal signature");
	}
	object_signals[ACTIVATE_REMOVE_SIGNAL] =
		g_signal_new ("activate_remove",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_remove),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);
	object_signals[ACTIVATE_CUT_SIGNAL] =
		g_signal_new ("activate_cut",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_cut),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);
	object_signals[ACTIVATE_COPY_SIGNAL] =
		g_signal_new ("activate_copy",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_copy),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);
	object_signals[ACTIVATE_PASTE_SIGNAL] =
		g_signal_new ("activate_paste",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (LMHostViewClass, activate_paste),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);

#line 268 "src/lm-host-view.gob"
	class->activate_add = ___real_lm_host_view_activate_add;
#line 288 "src/lm-host-view.gob"
	class->activate_move = ___real_lm_host_view_activate_move;
#line 343 "src/lm-host-view.gob"
	class->activate_remove = ___real_lm_host_view_activate_remove;
#line 494 "src/lm-host-view.gob"
	class->activate_cut = ___real_lm_host_view_activate_cut;
#line 501 "src/lm-host-view.gob"
	class->activate_copy = ___real_lm_host_view_activate_copy;
#line 507 "src/lm-host-view.gob"
	class->activate_paste = ___real_lm_host_view_activate_paste;
#line 447 "lm-host-view.c"
	g_object_class->constructor = ___constructor;
	g_object_class->finalize = ___finalize;
	g_object_class->get_property = ___object_get_property;
	g_object_class->set_property = ___object_set_property;
    {
	GParamSpec   *param_spec;

	param_spec = g_param_spec_pointer
		("applet" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (g_object_class,
		PROP_APPLET,
		param_spec);
	param_spec = g_param_spec_boolean
		("editing_host" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 FALSE /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_EDITING_HOST,
		param_spec);
	param_spec = g_param_spec_boolean
		("can_go_up" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 FALSE /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_CAN_GO_UP,
		param_spec);
	param_spec = g_param_spec_boolean
		("can_go_down" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 FALSE /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_CAN_GO_DOWN,
		param_spec);
    }
 {
#line 80 "src/lm-host-view.gob"

    GtkBindingSet *binding_set;

    global_clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);

    clipboard_target_native_atom = gdk_atom_intern(CLIPBOARD_TARGET_NATIVE_NAME, FALSE);

    binding_set = gtk_binding_set_by_class(class);

    /* Delete removes a row */
    gtk_binding_entry_add_signal(binding_set, GDK_Delete, 0, "activate-remove", 0);
    gtk_binding_entry_add_signal(binding_set, GDK_KP_Delete, 0, "activate-remove", 0);

    /* HIG 2.0 cut/copy/paste shortcuts */
    gtk_binding_entry_add_signal(binding_set, GDK_x, GDK_CONTROL_MASK, "activate-cut", 0);
    gtk_binding_entry_add_signal(binding_set, GDK_c, GDK_CONTROL_MASK, "activate-copy", 0);
    gtk_binding_entry_add_signal(binding_set, GDK_v, GDK_CONTROL_MASK, "activate-paste", 0);

    /* cut/copy/paste shortcuts taken from gtkentry.c */
    gtk_binding_entry_add_signal(binding_set, GDK_Delete, GDK_SHIFT_MASK, "activate-cut", 0);
    gtk_binding_entry_add_signal(binding_set, GDK_Insert, GDK_CONTROL_MASK, "activate-copy", 0);
    gtk_binding_entry_add_signal(binding_set, GDK_Insert, GDK_SHIFT_MASK, "activate-paste", 0);
  
#line 516 "lm-host-view.c"
 }
}
#undef __GOB_FUNCTION__

static void
___object_set_property (GObject *object,
	guint property_id,
	const GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "LM:Host:View::set_property"
{
	LMHostView *self G_GNUC_UNUSED;

	self = LM_HOST_VIEW (object);

	switch (property_id) {
	case PROP_APPLET:
		{
#line 53 "src/lm-host-view.gob"
self->_priv->applet = g_value_get_pointer (VAL);
#line 537 "lm-host-view.c"
		}
		break;
	case PROP_EDITING_HOST:
		{
#line 68 "src/lm-host-view.gob"
self->editing_host = g_value_get_boolean (VAL);
#line 544 "lm-host-view.c"
		}
		break;
	case PROP_CAN_GO_UP:
		{
#line 71 "src/lm-host-view.gob"
self->can_go_up = g_value_get_boolean (VAL);
#line 551 "lm-host-view.c"
		}
		break;
	case PROP_CAN_GO_DOWN:
		{
#line 74 "src/lm-host-view.gob"
self->can_go_down = g_value_get_boolean (VAL);
#line 558 "lm-host-view.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__

static void
___object_get_property (GObject *object,
	guint property_id,
	GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "LM:Host:View::get_property"
{
	LMHostView *self G_GNUC_UNUSED;

	self = LM_HOST_VIEW (object);

	switch (property_id) {
	case PROP_APPLET:
		{
#line 53 "src/lm-host-view.gob"
g_value_set_pointer (VAL, self->_priv->applet);
#line 589 "lm-host-view.c"
		}
		break;
	case PROP_EDITING_HOST:
		{
#line 68 "src/lm-host-view.gob"
g_value_set_boolean (VAL, self->editing_host);
#line 596 "lm-host-view.c"
		}
		break;
	case PROP_CAN_GO_UP:
		{
#line 71 "src/lm-host-view.gob"
g_value_set_boolean (VAL, self->can_go_up);
#line 603 "lm-host-view.c"
		}
		break;
	case PROP_CAN_GO_DOWN:
		{
#line 74 "src/lm-host-view.gob"
g_value_set_boolean (VAL, self->can_go_down);
#line 610 "lm-host-view.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__


#line 68 "src/lm-host-view.gob"
gboolean 
lm_host_view_get_editing_host (LMHostView * self)
{
#line 630 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::get_editing_host"
{
#line 68 "src/lm-host-view.gob"
		gboolean val; g_object_get (G_OBJECT (self), "editing_host", &val, NULL); return val;
}}
#line 636 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 68 "src/lm-host-view.gob"
void 
lm_host_view_set_editing_host (LMHostView * self, gboolean val)
{
#line 643 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::set_editing_host"
{
#line 68 "src/lm-host-view.gob"
		g_object_set (G_OBJECT (self), "editing_host", val, NULL);
}}
#line 649 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 71 "src/lm-host-view.gob"
gboolean 
lm_host_view_get_can_go_up (LMHostView * self)
{
#line 656 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::get_can_go_up"
{
#line 71 "src/lm-host-view.gob"
		gboolean val; g_object_get (G_OBJECT (self), "can_go_up", &val, NULL); return val;
}}
#line 662 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 71 "src/lm-host-view.gob"
void 
lm_host_view_set_can_go_up (LMHostView * self, gboolean val)
{
#line 669 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::set_can_go_up"
{
#line 71 "src/lm-host-view.gob"
		g_object_set (G_OBJECT (self), "can_go_up", val, NULL);
}}
#line 675 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 74 "src/lm-host-view.gob"
gboolean 
lm_host_view_get_can_go_down (LMHostView * self)
{
#line 682 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::get_can_go_down"
{
#line 74 "src/lm-host-view.gob"
		gboolean val; g_object_get (G_OBJECT (self), "can_go_down", &val, NULL); return val;
}}
#line 688 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 74 "src/lm-host-view.gob"
void 
lm_host_view_set_can_go_down (LMHostView * self, gboolean val)
{
#line 695 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::set_can_go_down"
{
#line 74 "src/lm-host-view.gob"
		g_object_set (G_OBJECT (self), "can_go_down", val, NULL);
}}
#line 701 "lm-host-view.c"
#undef __GOB_FUNCTION__


#line 104 "src/lm-host-view.gob"
static void 
lm_host_view_constructor (LMHostView * self)
{
#line 709 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::constructor"
{
#line 105 "src/lm-host-view.gob"
	
    GtkMenuShell *shell;
    GtkWidget *add_item;
    GtkListStore *store;
    GtkCellRenderer *renderer;
    GtkTreeViewColumn *column;
    GtkTreeSelection *selection;
    int i;

    gtk_tree_view_set_reorderable(GTK_TREE_VIEW(self), TRUE);
    gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(self), self_search_equal_cb, NULL, NULL);

    shell = GTK_MENU_SHELL(selfp->menu);

    add_item = lm_menu_shell_append(shell, GTK_STOCK_ADD, NULL);
    selfp->remove_item = lm_menu_shell_append(shell, GTK_STOCK_REMOVE, NULL);
    lm_menu_shell_append(shell, NULL, NULL);
    selfp->up_item = lm_menu_shell_append(shell, GTK_STOCK_GO_UP, _("Move _Up"));
    selfp->down_item = lm_menu_shell_append(shell, GTK_STOCK_GO_DOWN, _("Move _Down"));
    lm_menu_shell_append(shell, NULL, NULL);
    selfp->cut_item = lm_menu_shell_append(shell, GTK_STOCK_CUT, NULL);
    selfp->copy_item = lm_menu_shell_append(shell, GTK_STOCK_COPY, NULL);
    selfp->paste_item = lm_menu_shell_append(shell, GTK_STOCK_PASTE, NULL);
    lm_menu_shell_append(shell, NULL, NULL);
    selfp->select_all_item = lm_menu_shell_append(shell, GTK_STOCK_SELECT_ALL, NULL);

    g_signal_connect_swapped(add_item, "activate", G_CALLBACK(self_activate_add), self);
    g_signal_connect_swapped(selfp->remove_item, "activate", G_CALLBACK(self_activate_remove), self);
    g_signal_connect(selfp->up_item, "activate", G_CALLBACK(self_up_activate_h), self);
    g_signal_connect(selfp->down_item, "activate", G_CALLBACK(self_down_activate_h), self);
    g_signal_connect_swapped(selfp->cut_item, "activate", G_CALLBACK(self_activate_cut), self);
    g_signal_connect_swapped(selfp->copy_item, "activate", G_CALLBACK(self_activate_copy), self);
    g_signal_connect_swapped(selfp->paste_item, "activate", G_CALLBACK(self_activate_paste), self);
    g_signal_connect(selfp->select_all_item, "activate", G_CALLBACK(self_select_all_activate_h), self);

    store = gtk_list_store_new(N_COLUMNS,
			       LM_TYPE_HOST_FRONTEND,
			       GDK_TYPE_COLOR,
			       G_TYPE_STRING);
    gtk_tree_view_set_model(GTK_TREE_VIEW(self), GTK_TREE_MODEL(store));

    renderer = lm_cell_renderer_color_new();
    g_signal_connect(renderer, "activated", G_CALLBACK(self_color_activated_h), self);

    column = gtk_tree_view_column_new_with_attributes(_("Color"),
						      renderer,
						      "color", COLUMN_COLOR,
						      NULL);
    gtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_AUTOSIZE);
    gtk_tree_view_append_column(GTK_TREE_VIEW(self), column);

    renderer = gtk_cell_renderer_text_new();
    g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
    g_object_connect(renderer,
		     "signal::editing-started", self_editing_started_h, self,
		     "signal::editing-canceled", self_editing_canceled_h, self,
		     "signal::edited", self_edited_h, self,
		     NULL);

    column = gtk_tree_view_column_new_with_attributes(_("Host"),
						      renderer,
						      "text", COLUMN_NAME,
						      NULL);
    gtk_tree_view_column_set_sizing(column, GTK_TREE_VIEW_COLUMN_AUTOSIZE);
    gtk_tree_view_append_column(GTK_TREE_VIEW(self), column);

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self));
    gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);
    g_signal_connect(selection, "changed", G_CALLBACK(self_selection_changed_h), self);

    /* fill */
    LM_ARRAY_FOREACH(i, selfp->applet->hosts)
      {
	LMHostFrontend *host = g_ptr_array_index(selfp->applet->hosts, i);
	GtkTreeIter iter;

	gtk_list_store_insert_with_values(store, &iter,
					  G_MAXINT,
					  COLUMN_HOST, host,
					  COLUMN_COLOR, &host->color,
					  COLUMN_NAME, LM_HOST(host)->name,
					  -1);
      }

    g_object_connect(store,
		     /* for the sensitivity of "Select All" */
		     "swapped-signal::row-inserted", self_update_sensitivity, self,
		     "swapped-signal::row-deleted", self_update_sensitivity, self,
		     /* handle row dnd */
		     "swapped-signal::row-deleted", self_reorder, self,
		     NULL);

    g_object_unref(store);

    g_object_connect(self,
		     "signal::popup-menu", self_popup_menu_h, NULL,
		     "signal::button-press-event", self_button_press_event_h, NULL,
		     NULL);

    self_update_sensitivity(self);
  }}
#line 814 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 207 "src/lm-host-view.gob"
static GSList * 
lm_host_view_get_selected_rows (LMHostView * self)
{
#line 821 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::get_selected_rows"
#line 207 "src/lm-host-view.gob"
	g_return_val_if_fail (self != NULL, (GSList * )0);
#line 207 "src/lm-host-view.gob"
	g_return_val_if_fail (LM_IS_HOST_VIEW (self), (GSList * )0);
#line 827 "lm-host-view.c"
{
#line 209 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GtkTreeSelection *selection;
    GList *paths;
    GList *l;
    GSList *references = NULL;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self));
    paths = gtk_tree_selection_get_selected_rows(selection, NULL);

    LM_LIST_FOREACH(l, paths)
      {
	GtkTreePath *path = l->data;

	references = g_slist_append(references, gtk_tree_row_reference_new(model, path));
	gtk_tree_path_free(path);
      }
    g_list_free(paths);

    return references;
  }}
#line 852 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 232 "src/lm-host-view.gob"
static void 
lm_host_view_store_remove (LMHostView * self, GtkListStore * store, GtkTreeIter * iter)
{
#line 859 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::store_remove"
#line 232 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 232 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 232 "src/lm-host-view.gob"
	g_return_if_fail (store != NULL);
#line 232 "src/lm-host-view.gob"
	g_return_if_fail (GTK_IS_LIST_STORE (store));
#line 232 "src/lm-host-view.gob"
	g_return_if_fail (iter != NULL);
#line 871 "lm-host-view.c"
{
#line 236 "src/lm-host-view.gob"
	
    /* block dnd handler */
    g_signal_handlers_block_by_func(store, self_reorder, self);
    gtk_list_store_remove(store, iter);
    g_signal_handlers_unblock_by_func(store, self_reorder, self);
  }}
#line 880 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 243 "src/lm-host-view.gob"
static void 
lm_host_view_reorder (LMHostView * self)
{
#line 887 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::reorder"
#line 243 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 243 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 893 "lm-host-view.c"
{
#line 245 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    gboolean valid;
    GtkTreeIter iter;
    GSList *hosts = NULL;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    valid = gtk_tree_model_get_iter_first(model, &iter);

    while (valid)
      {
	LMHostFrontend *host;

	gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);
	hosts = g_slist_append(hosts, host);

	valid = gtk_tree_model_iter_next(model, &iter);
      }

    lm_applet_reorder_hosts(selfp->applet, hosts);
    lm_g_object_slist_free(hosts);
  }}
#line 918 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 268 "src/lm-host-view.gob"
void 
lm_host_view_activate_add (LMHostView * self)
{
#line 925 "lm-host-view.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 268 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 268 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 936 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_ADD_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 268 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_add (LMHostView * self)
{
#line 953 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_add"
{
#line 270 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GtkTreePath *path;
    GtkTreeViewColumn *column;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    gtk_list_store_append(GTK_LIST_STORE(model), &selfp->add_pending_iter);
    selfp->add_pending_count++;

    path = gtk_tree_model_get_path(model, &selfp->add_pending_iter);
    column = gtk_tree_view_get_column(GTK_TREE_VIEW(self), 1);

    gtk_widget_grab_focus(GTK_WIDGET(self));
    gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(self), path, column, FALSE, 0, 0);
    gtk_tree_view_set_cursor(GTK_TREE_VIEW(self), path, column, TRUE);
    gtk_tree_path_free(path);
  }}
#line 974 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 288 "src/lm-host-view.gob"
void 
lm_host_view_activate_move (LMHostView * self, int direction)
{
#line 981 "lm-host-view.c"
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 288 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 288 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 992 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_INT);
	g_value_set_int (&___param_values[1], (gint ) direction);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_MOVE_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 288 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_move (LMHostView * self, int direction)
{
#line 1014 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_move"
{
#line 290 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GSList *references;
    GSList *l;

    g_return_if_fail(direction == -1 || direction == +1);

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    references = self_get_selected_rows(self);
    if (direction == +1)
      references = g_slist_reverse(references);

    LM_LIST_FOREACH(l, references)
      {
	GtkTreeRowReference *reference = l->data;
	GtkTreePath *path;
	GtkTreeIter iter;
	GtkTreeIter other_iter;
	gboolean status;

	path = gtk_tree_row_reference_get_path(reference);

	status = gtk_tree_model_get_iter(model, &iter, path);
	g_assert(status == TRUE);

	if (direction == -1)
	  gtk_tree_path_prev(path);
	else
	  gtk_tree_path_next(path);

	if (gtk_tree_model_get_iter(model, &other_iter, path))
	  {
	    LMHostFrontend *host;
	    LMHostFrontend *other_host;

	    gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);
	    gtk_tree_model_get(model, &other_iter, COLUMN_HOST, &other_host, -1);

	    gtk_list_store_swap(GTK_LIST_STORE(model), &iter, &other_iter);

	    g_object_unref(host);
	    g_object_unref(other_host);
	  }

	gtk_tree_path_free(path);
	gtk_tree_row_reference_free(reference);
      }
    g_slist_free(references);

    self_reorder(self);
    self_update_sensitivity(self); /* for up and down */
  }}
#line 1070 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 343 "src/lm-host-view.gob"
void 
lm_host_view_activate_remove (LMHostView * self)
{
#line 1077 "lm-host-view.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 343 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 343 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1088 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_REMOVE_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 343 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_remove (LMHostView * self)
{
#line 1105 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_remove"
{
#line 345 "src/lm-host-view.gob"
	
    self_remove_selected_hosts(self);
  }}
#line 1112 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 349 "src/lm-host-view.gob"
static void 
lm_host_view_remove_selected_hosts (LMHostView * self)
{
#line 1119 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::remove_selected_hosts"
#line 349 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 349 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1125 "lm-host-view.c"
{
#line 351 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GSList *references;
    GSList *l;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    references = self_get_selected_rows(self);
    LM_LIST_FOREACH(l, references)
      {
	GtkTreeRowReference *reference = l->data;
	GtkTreeIter iter;
	gboolean status;
	LMHostFrontend *host;

	/* if the color dialog is associated with the host, destroy it */
	if (selfp->color_dialog_row_reference
	    && ! lm_tree_row_reference_compare(reference,
					       selfp->color_dialog_row_reference))
	  gtk_widget_destroy(selfp->color_dialog);

	status = lm_tree_row_reference_get_iter(reference, &iter);
	g_assert(status == TRUE);

	gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);

	lm_applet_remove_host(selfp->applet, host);
	self_store_remove(self, GTK_LIST_STORE(model), &iter);

	g_object_unref(host);
	gtk_tree_row_reference_free(reference);
      }
    g_slist_free(references);
  }}
#line 1161 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 385 "src/lm-host-view.gob"
static void 
lm_host_view_copy_selected_hosts (LMHostView * self)
{
#line 1168 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::copy_selected_hosts"
#line 385 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 385 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1174 "lm-host-view.c"
{
#line 387 "src/lm-host-view.gob"
	
    GSList *host_configs = NULL;
    GtkTreeModel *model;
    GSList *references;
    GSList *l;
    gboolean status;
    static const GtkTargetEntry init_target_table[] = {
      { CLIPBOARD_TARGET_NATIVE_NAME, 0, CLIPBOARD_TARGET_NATIVE }
    };
    GtkTargetList *target_list;
    GtkTargetEntry *target_table;
    int target_table_len;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));

    references = self_get_selected_rows(self);
    LM_LIST_FOREACH(l, references)
      {
	GtkTreeRowReference *reference = l->data;
	GtkTreePath *path;
	GtkTreeIter iter;
	LMHostFrontend *host;

	path = gtk_tree_row_reference_get_path(reference);
	status = gtk_tree_model_get_iter(model, &iter, path);
	g_assert(status == TRUE);
	gtk_tree_path_free(path);

	gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);
	host_configs = g_slist_append(host_configs, lm_host_frontend_get_configuration(host));
	g_object_unref(host);

	gtk_tree_row_reference_free(reference);
      }
    g_slist_free(references);

    target_list = gtk_target_list_new(init_target_table, G_N_ELEMENTS(init_target_table));
    gtk_target_list_add_text_targets(target_list, CLIPBOARD_TARGET_TEXT);

    target_table = gtk_target_table_new_from_list(target_list, &target_table_len);
    gtk_target_list_unref(target_list);

    status = gtk_clipboard_set_with_data(global_clipboard,
					 target_table,
					 target_table_len,
					 self_get_clipboard_cb,
					 self_clear_clipboard_cb,
					 host_configs);
    g_assert(status == TRUE);

    gtk_target_table_free(target_table, target_table_len);
  }}
#line 1229 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 440 "src/lm-host-view.gob"
static void 
lm_host_view_get_clipboard_cb (GtkClipboard * clipboard, GtkSelectionData * selection_data, unsigned int info, gpointer user_data_or_owner)
{
#line 1236 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::get_clipboard_cb"
{
#line 445 "src/lm-host-view.gob"
	
    GSList *host_configs = user_data_or_owner;
    GSList *l;

    switch ((ClipboardTarget) info)
      {
      case CLIPBOARD_TARGET_NATIVE:
	gtk_selection_data_set(selection_data,
			       clipboard_target_native_atom,
			       8,
			       (unsigned char *) &host_configs,
			       sizeof(host_configs));
	break;

      case CLIPBOARD_TARGET_TEXT:
	{
	  GString *str;

	  str = g_string_new(NULL);

	  LM_LIST_FOREACH(l, host_configs)
	    {
	      LMHostFrontendConfiguration *config = l->data;

	      g_string_append(str, config->name);

	      if (l->next)
		g_string_append_c(str, '\n');
	    }

	  gtk_selection_data_set_text(selection_data, str->str, str->len);
	  g_string_free(str, TRUE);
	}
	break;

      default:
	g_assert_not_reached();
	break;
      }
  }}
#line 1280 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 486 "src/lm-host-view.gob"
static void 
lm_host_view_clear_clipboard_cb (GtkClipboard * clipboard, gpointer user_data_or_owner)
{
#line 1287 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::clear_clipboard_cb"
{
#line 488 "src/lm-host-view.gob"
	
    GSList *host_configs = user_data_or_owner;

    lm_g_slist_free_deep_custom(host_configs, (GFunc) lm_host_frontend_configuration_free, NULL);
  }}
#line 1296 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 494 "src/lm-host-view.gob"
static void 
lm_host_view_activate_cut (LMHostView * self)
{
#line 1303 "lm-host-view.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 494 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 494 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1314 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_CUT_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 494 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_cut (LMHostView * self)
{
#line 1331 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_cut"
{
#line 496 "src/lm-host-view.gob"
	
    self_copy_selected_hosts(self);
    self_remove_selected_hosts(self);
  }}
#line 1339 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 501 "src/lm-host-view.gob"
static void 
lm_host_view_activate_copy (LMHostView * self)
{
#line 1346 "lm-host-view.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 501 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 501 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1357 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_COPY_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 501 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_copy (LMHostView * self)
{
#line 1374 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_copy"
{
#line 503 "src/lm-host-view.gob"
	
    self_copy_selected_hosts(self);
  }}
#line 1381 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 507 "src/lm-host-view.gob"
static void 
lm_host_view_activate_paste (LMHostView * self)
{
#line 1388 "lm-host-view.c"
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 507 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 507 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1399 "lm-host-view.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ACTIVATE_PASTE_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 507 "src/lm-host-view.gob"
static void 
___real_lm_host_view_activate_paste (LMHostView * self)
{
#line 1416 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::activate_paste"
{
#line 509 "src/lm-host-view.gob"
	
    GtkSelectionData *data;
    char *text;

    data = gtk_clipboard_wait_for_contents(global_clipboard, clipboard_target_native_atom);
    if (data)
      {
	GSList *host_configs;
	GSList *l;

	memcpy(&host_configs, data->data, data->length);

	LM_LIST_FOREACH(l, host_configs)
	  {
	    LMHostFrontendConfiguration *config = l->data;
	    LMHostFrontend *host;

	    host = lm_host_frontend_new_from_configuration(selfp->applet, config);
	    self_add_host(self, host);
	    g_object_unref(host);
	  }

	gtk_selection_data_free(data);
	return;
      }

    text = gtk_clipboard_wait_for_text(global_clipboard);
    if (text)
      {
	char **hosts;
	int i;

	hosts = g_strsplit(text, "\n", 0);
	g_free(text);

	for (i = 0; hosts[i]; i++)
	  {
	    LMHostFrontend *host;

	    host = lm_host_frontend_new(selfp->applet, hosts[i], NULL);
	    self_add_host(self, host);
	    g_object_unref(host);
	  }

	g_strfreev(hosts);
      }
  }}
#line 1467 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 557 "src/lm-host-view.gob"
static void 
lm_host_view_add_host (LMHostView * self, LMHostFrontend * host)
{
#line 1474 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::add_host"
#line 557 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 557 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 557 "src/lm-host-view.gob"
	g_return_if_fail (host != NULL);
#line 557 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_FRONTEND (host));
#line 1484 "lm-host-view.c"
{
#line 559 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GtkTreeIter iter;

    lm_applet_add_host(selfp->applet, host);

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));

    gtk_list_store_insert_with_values(GTK_LIST_STORE(model), &iter,
				      G_MAXINT,
				      COLUMN_HOST, host,
				      COLUMN_COLOR, &host->color,
				      COLUMN_NAME, LM_HOST(host)->name,
				      -1);
  }}
#line 1502 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 575 "src/lm-host-view.gob"
static void 
lm_host_view_selection_changed_h (GtkTreeSelection * selection, gpointer user_data)
{
#line 1509 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::selection_changed_h"
{
#line 578 "src/lm-host-view.gob"
	
    Self *self = user_data;

    self_update_sensitivity(self);
  }}
#line 1518 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 584 "src/lm-host-view.gob"
static void 
lm_host_view_color_activated_h (LMCellRendererColor * renderer, const char * path, gpointer user_data)
{
#line 1525 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::color_activated_h"
{
#line 588 "src/lm-host-view.gob"
	
    Self *self = user_data;
    GtkTreeModel *model;
    GtkTreeIter iter;
    gboolean status;
    LMHostFrontend *host;
    GtkWindow *parent_window;

    if (! selfp->color_dialog)
      {
	selfp->color_dialog = gtk_color_selection_dialog_new(_("Pick a Color"));

	g_object_weak_ref(G_OBJECT(selfp->color_dialog), self_color_dialog_weak_notify_cb, self);

	g_signal_connect(selfp->color_dialog, "response", G_CALLBACK(self_color_dialog_response_h), self);
      }

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));

    status = gtk_tree_model_get_iter_from_string(model, &iter, path);
    g_assert(status == TRUE);

    gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);
    gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG(selfp->color_dialog)->colorsel), &host->color);
    g_object_unref(host);

    gtk_tree_row_reference_free(selfp->color_dialog_row_reference);
    selfp->color_dialog_row_reference = lm_tree_row_reference_new_from_path_string(model, path);

    parent_window = lm_widget_get_parent_window(GTK_WIDGET(self));
    if (parent_window)
      {
	if (parent_window != gtk_window_get_transient_for(GTK_WINDOW(selfp->color_dialog)))
	  gtk_window_set_transient_for(GTK_WINDOW(selfp->color_dialog), parent_window);

	gtk_window_set_modal(GTK_WINDOW(selfp->color_dialog), gtk_window_get_modal(parent_window));
      }

    lm_window_present_from_event(GTK_WINDOW(selfp->color_dialog));
  }}
#line 1569 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 629 "src/lm-host-view.gob"
static void 
lm_host_view_color_dialog_response_h (GtkDialog * dialog, int response, gpointer user_data)
{
#line 1576 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::color_dialog_response_h"
{
#line 633 "src/lm-host-view.gob"
	
    Self *self = user_data;

    if (response == GTK_RESPONSE_OK)
      {
	GdkColor color;
	GtkTreeModel *model;
	GtkTreeIter iter;
	gboolean status;
	LMHostFrontend *host;

	gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG(dialog)->colorsel), &color);

	model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));

	status = lm_tree_row_reference_get_iter(selfp->color_dialog_row_reference, &iter);
	g_assert(status == TRUE);

	gtk_tree_model_get(model, &iter, COLUMN_HOST, &host, -1);
	lm_host_frontend_set_color(host, &color);
	g_object_unref(host);

	gtk_list_store_set(GTK_LIST_STORE(model), &iter,
			   COLUMN_COLOR, &color,
			   -1);
      }

    gtk_widget_destroy(GTK_WIDGET(dialog));
  }}
#line 1609 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 663 "src/lm-host-view.gob"
static void 
lm_host_view_color_dialog_weak_notify_cb (gpointer data, GObject * former_dialog)
{
#line 1616 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::color_dialog_weak_notify_cb"
{
#line 665 "src/lm-host-view.gob"
	
    Self *self = data;

    selfp->color_dialog = NULL;

    gtk_tree_row_reference_free(selfp->color_dialog_row_reference);
    selfp->color_dialog_row_reference = NULL;
  }}
#line 1628 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 674 "src/lm-host-view.gob"
static void 
lm_host_view_editing_started_h (GtkCellRenderer * renderer, GtkCellEditable * editable, char * path, gpointer user_data)
{
#line 1635 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::editing_started_h"
{
#line 679 "src/lm-host-view.gob"
	
    Self *self = user_data;

    self_set_editing_host(self, TRUE);
  }}
#line 1644 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 685 "src/lm-host-view.gob"
static void 
lm_host_view_editing_canceled_h (GtkCellRenderer * renderer, gpointer user_data)
{
#line 1651 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::editing_canceled_h"
{
#line 688 "src/lm-host-view.gob"
	
    Self *self = user_data;

    self_set_editing_host(self, FALSE);

    if (selfp->add_pending_count)
      {
	GtkTreeModel *model;

	selfp->add_pending_count--;
	model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
	self_store_remove(self, GTK_LIST_STORE(model), &selfp->add_pending_iter);
      }
  }}
#line 1669 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 703 "src/lm-host-view.gob"
static void 
lm_host_view_edited_h (GtkCellRendererText * renderer, const char * path_string, const char * new_text, gpointer user_data)
{
#line 1676 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::edited_h"
{
#line 708 "src/lm-host-view.gob"
	
    Self *self = user_data;
    GtkTreeModel *model;
    gboolean status;
    GtkTreeIter iter;
    LMHostFrontend *old_host;
    LMHostFrontend *new_host;

    self_set_editing_host(self, FALSE);

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    status = gtk_tree_model_get_iter_from_string(model, &iter, path_string);
    g_assert(status == TRUE);

    gtk_tree_model_get(model, &iter, COLUMN_HOST, &old_host, -1);

    if (old_host)
      {
	new_host = lm_host_frontend_new(selfp->applet, new_text, &old_host->color);
	lm_applet_replace_host(selfp->applet, old_host, new_host);
	g_object_unref(old_host);
      }
    else
      {
	new_host = lm_host_frontend_new(selfp->applet, new_text, NULL);
	lm_applet_add_host(selfp->applet, new_host);
      }

    gtk_list_store_set(GTK_LIST_STORE(model), &iter,
		       COLUMN_HOST, new_host,
		       COLUMN_COLOR, &new_host->color,
		       COLUMN_NAME, LM_HOST(new_host)->name,
		       -1);

    g_object_unref(new_host);

    if (selfp->add_pending_count)
      selfp->add_pending_count--;
  }}
#line 1719 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 748 "src/lm-host-view.gob"
static void 
lm_host_view_update_sensitivity (LMHostView * self)
{
#line 1726 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::update_sensitivity"
#line 748 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 748 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1732 "lm-host-view.c"
{
#line 750 "src/lm-host-view.gob"
	
    GtkTreeModel *model;
    GtkTreeSelection *selection;
    GList *paths;
    gboolean has_selection = FALSE;
    gboolean has_prev = FALSE;
    gboolean has_next = FALSE;
    GtkTreeIter iter;
    gboolean has_hosts;

    model = gtk_tree_view_get_model(GTK_TREE_VIEW(self));
    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self));
    paths = gtk_tree_selection_get_selected_rows(selection, NULL);

    if (paths)
      {
	GList *l;
	gboolean status;

	has_selection = TRUE;

	/* has prev? */

	l = paths;
	if (gtk_tree_path_prev(l->data))
	  {
	    gtk_tree_path_next(l->data); /* restore it */
	    has_prev = TRUE;
	  }

	/* has next? */

	l = g_list_last(paths);
	status = gtk_tree_model_get_iter(model, &iter, l->data);
	g_assert(status == TRUE);
	if (gtk_tree_model_iter_next(model, &iter))
	  has_next = TRUE;

	/* cleanup */

	LM_LIST_FOREACH(l, paths)
	  gtk_tree_path_free(l->data);
	g_list_free(paths);
      }

    self_set_can_go_up(self, has_prev);
    self_set_can_go_down(self, has_next);

    gtk_widget_set_sensitive(selfp->remove_item, has_selection);
    gtk_widget_set_sensitive(selfp->cut_item, has_selection);
    gtk_widget_set_sensitive(selfp->copy_item, has_selection);
    gtk_widget_set_sensitive(selfp->up_item, has_prev);
    gtk_widget_set_sensitive(selfp->down_item, has_next);

    has_hosts = gtk_tree_model_get_iter_first(model, &iter);
    gtk_widget_set_sensitive(selfp->select_all_item, has_hosts);
  }}
#line 1792 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 808 "src/lm-host-view.gob"
static void 
lm_host_view_popup_menu (LMHostView * self, int button, guint32 activate_time)
{
#line 1799 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::popup_menu"
#line 808 "src/lm-host-view.gob"
	g_return_if_fail (self != NULL);
#line 808 "src/lm-host-view.gob"
	g_return_if_fail (LM_IS_HOST_VIEW (self));
#line 1805 "lm-host-view.c"
{
#line 810 "src/lm-host-view.gob"
	
    Self **self_box;

    gtk_widget_set_sensitive(selfp->paste_item, FALSE);

    /* do not crash if self is finalized before the request completes */
    self_box = g_new(Self *, 1);
    *self_box = self;
    lm_add_weak_pointer(self_box);

    gtk_clipboard_request_targets(global_clipboard, self_popup_menu_targets_received_cb, self_box);

    gtk_menu_popup(GTK_MENU(selfp->menu), NULL, NULL, NULL, NULL, button, activate_time);
  }}
#line 1822 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 825 "src/lm-host-view.gob"
static void 
lm_host_view_popup_menu_targets_received_cb (GtkClipboard * clipboard, GdkAtom * atoms, int n_atoms, gpointer data)
{
#line 1829 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::popup_menu_targets_received_cb"
{
#line 830 "src/lm-host-view.gob"
	
    Self **self_box = data;
    Self *self = *self_box;

    if (self)
      {
	if (atoms)
	  gtk_widget_set_sensitive(selfp->paste_item, self_can_paste(atoms, n_atoms));

	lm_remove_weak_pointer(self_box);
      }

    g_free(self_box);
  }}
#line 1847 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 845 "src/lm-host-view.gob"
static gboolean 
lm_host_view_can_paste (GdkAtom * atoms, int n_atoms)
{
#line 1854 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::can_paste"
{
#line 847 "src/lm-host-view.gob"
	
    int i;

    for (i = 0; i < n_atoms; i++)
      if (atoms[i] == CLIPBOARD_TARGET_NATIVE)
	return TRUE;

    return gtk_targets_include_text(atoms, n_atoms);
  }}
#line 1867 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 857 "src/lm-host-view.gob"
static gboolean 
lm_host_view_popup_menu_h (GtkWidget * widget, gpointer user_data)
{
#line 1874 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::popup_menu_h"
{
#line 859 "src/lm-host-view.gob"
	
    Self *self = SELF(widget);

    self_popup_menu(self, 0, gtk_get_current_event_time());
    gtk_menu_shell_select_first(GTK_MENU_SHELL(selfp->menu), FALSE);

    return TRUE;		/* a menu was activated */
  }}
#line 1886 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 868 "src/lm-host-view.gob"
static gboolean 
lm_host_view_button_press_event_h (GtkWidget * widget, GdkEventButton * event, gpointer user_data)
{
#line 1893 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::button_press_event_h"
{
#line 872 "src/lm-host-view.gob"
	
    if (event->button == 3)
      self_popup_menu(SELF(widget), event->button, event->time);

    return FALSE;		/* propagate event */
  }}
#line 1903 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 879 "src/lm-host-view.gob"
static void 
lm_host_view_select_all_activate_h (GtkMenuItem * item, gpointer user_data)
{
#line 1910 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::select_all_activate_h"
{
#line 881 "src/lm-host-view.gob"
	
    Self *self = user_data;
    GtkTreeSelection *selection;

    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self));
    gtk_tree_selection_select_all(selection);
  }}
#line 1921 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 889 "src/lm-host-view.gob"
static void 
lm_host_view_up_activate_h (GtkMenuItem * item, gpointer user_data)
{
#line 1928 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::up_activate_h"
{
#line 891 "src/lm-host-view.gob"
	
    Self *self = user_data;
    self_activate_move(self, -1);
  }}
#line 1936 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 896 "src/lm-host-view.gob"
static void 
lm_host_view_down_activate_h (GtkMenuItem * item, gpointer user_data)
{
#line 1943 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::down_activate_h"
{
#line 898 "src/lm-host-view.gob"
	
    Self *self = user_data;
    self_activate_move(self, +1);
  }}
#line 1951 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 903 "src/lm-host-view.gob"
static gboolean 
lm_host_view_search_equal_cb (GtkTreeModel * model, int column, const char * key, GtkTreeIter * iter, gpointer search_data)
{
#line 1958 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::search_equal_cb"
{
#line 909 "src/lm-host-view.gob"
	
    gboolean status = TRUE;
    GValue value = { 0, };
    GValue transformed = { 0, };
    const char *str;
    char *normalized_string;
    char *normalized_key;

    /*
     * The stock gtk_tree_view_search_equal_func() only searches the
     * start of the string, using strncmp(). We use strstr(), to
     * search anywhere inside the string.
     */

    gtk_tree_model_get_value(model, iter, column, &value);

    g_value_init(&transformed, G_TYPE_STRING);

    if (! g_value_transform(&value, &transformed))
      {
	g_value_unset(&value);
	return TRUE;
      }

    g_value_unset(&value);

    str = g_value_get_string(&transformed);
    if (! str)
      {
	g_value_unset(&transformed);
	return TRUE;
      }

    normalized_string = g_utf8_normalize(str, -1, G_NORMALIZE_ALL);
    normalized_key = g_utf8_normalize(key, -1, G_NORMALIZE_ALL);

    if (normalized_string && normalized_key)
      {
	char *case_normalized_string;
	char *case_normalized_key;

	case_normalized_string = g_utf8_casefold(normalized_string, -1);
	case_normalized_key = g_utf8_casefold(normalized_key, -1);

	if (strstr(case_normalized_string, case_normalized_key))
	  status = FALSE;

	g_free(case_normalized_string);
	g_free(case_normalized_key);
      }

    g_value_unset (&transformed);
    g_free(normalized_key);
    g_free(normalized_string);

    return status;
  }}
#line 2019 "lm-host-view.c"
#undef __GOB_FUNCTION__

#line 967 "src/lm-host-view.gob"
GtkWidget * 
lm_host_view_new (LMApplet * applet)
{
#line 2026 "lm-host-view.c"
#define __GOB_FUNCTION__ "LM:Host:View::new"
#line 967 "src/lm-host-view.gob"
	g_return_val_if_fail (applet != NULL, (GtkWidget * )0);
#line 967 "src/lm-host-view.gob"
	g_return_val_if_fail (LM_IS_APPLET (applet), (GtkWidget * )0);
#line 2032 "lm-host-view.c"
{
#line 969 "src/lm-host-view.gob"
	
    return GTK_WIDGET(GET_NEW_VARG(LM_HOST_VIEW_PROP_APPLET(applet), NULL));
  }}
#line 2038 "lm-host-view.c"
#undef __GOB_FUNCTION__
